% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tissueSpecificRegression.R
\name{tissueSpecificRegression}
\alias{tissueSpecificRegression}
\title{Tissue-specific regression}
\usage{
tissueSpecificRegression(
  counts,
  ercc,
  annots,
  tissues,
  mean_design = ~1,
  normalization_groups = NULL,
  max_iterations = 10L,
  wald_test = TRUE,
  cores = parallel::detectCores() - 1
)
}
\arguments{
\item{counts}{RNA-seq biological count \code{matrix} (genes as rows, samples as columns)}

\item{ercc}{ERCC spike-ins count \code{matrix} (ERCC as rows, samples as columns)}

\item{annots}{Sample annotations \code{data.frame}}

\item{tissues}{\code{vector} with tissues as values and genes as names (have to match \code{rownames(counts)})}

\item{mean_design}{\code{formula} that expresses how \code{counts} depend on variables in \code{annots}}

\item{normalization_groups}{optional \code{factor} specifying which samples correspond to which group for normalization.
Passed to \code{clusters} argument of \link[scran]{computeSumFactors})}

\item{max_iterations}{\code{integer} specifying maximum number of iterations for maximum-likelihood estimation}

\item{wald_test}{\code{logical} specifying is Wald test should be performed on regression coefficients}

\item{cores}{\code{integer} specifying number of cores to be used for parallelization
Passed to \code{mc.cores} argument of \link[parallel]{mclapply})}
}
\value{
A list with the following items:
\itemize{
\item tech_factors: Technical factors (i.e. normalization factors for ERCC-spikeins)
\item tissue_size_factors: Tissue-specific size factor (normalization factors for tissue-unique genes divided by normalization factors for ERCC-spikeins)
\item final_norm_factors: Gene-specific normalization factors to account for tissue differences.
\item coefficients: Regression regressions.
\item dispersions: Over-dispersion of negative binomial distribution.
\item proportions: Proportion each tissue contributes to total counts of genes.
\item convergence: \code{integer} specifying if the model converged? Possible values means that yes. Output of \link[lbfgs]{lbfgs}.
\item counts: Raw count \code{matrix}
\item norm Normalized count \code{matrix}
\item coefficients_se Standard-error of parameter estimates
\item pvalue Wald test p-values
\item padj Wald test FDR}
}
\description{
Normalizes and performs differential analysis of
single-individual transcriptomics data while accouting for
relative differences in tissue size between individuals.
}
\details{
Technical and size factors rely on the normalization procedure implemented as \link[scran]{computeSumFactors}.

To estimate regression coefficients, proportions and over-dispersion, we use an iterative approach similar to what is performed in the R function \link[MASS]{glm.nb}. We first get initial estimates of these regression coefficients and proportions assuming that counts are drawn from a Poisson distribution. The iterative procedure consists in estimating the over-dispersion given the mean using the \link[MASS]{theta.ml} function and then in estimating regression coefficients and proportions while keeping the over-dispersion fixed. We repeat this until parameters converge. Optimization is performed using L-BFGS as implemented by \link[lbfgs]{lbfgs}

Wald test is performed by using the inverse of the numerical hessian matrix as an estimate of the standard-error.

P-values are adjusted using FDR as implemented by \link[stats]{p.adjust}.
}
\examples{
nsamples <- 500
ngenes <- 150
ntissueuniq <- 50
nercc <- 50
ntissues <- 2

sample_names <- paste0("Sample", seq_len(nsamples))
gene_names <- paste0("Gene", seq_len(ngenes))
ercc_names <- paste0("ERCC", seq_len(nercc))
tissue_names <- paste0("Tissue", seq_len(ntissues))

# simulate gene mean
mu_gene <- rlnorm(ngenes, meanlog = 5)
mu_ercc <- rlnorm(ngenes, meanlog = 5)

# simulate size and technical factors
size_factors <- sapply(seq_len(ntissues), function(i) {
  k <- rlnorm(nsamples, 0, 1)
  k/mean(k)
})
rownames(size_factors) <- sample_names
colnames(size_factors) <- tissue_names

tech_factors <- rlnorm(nsamples, 0, 1)
names(tech_factors) <- sample_names
tech_factors <- tech_factors/mean(tech_factors)

# genes are from which tissue
tissues <- sample(tissue_names, size = ntissueuniq, replace = TRUE)
names(tissues) <- sample(gene_names, ntissueuniq)

# simulate tissue proportions
prop <- sapply(seq_len(ntissues), function(i) rnorm(ngenes, 0, 1))
prop <- t(apply(prop, 1, function(x) x^2/sum(x^2)))
rownames(prop) <- gene_names
colnames(prop) <- tissue_names
for (i in tissue_names) {
  prop[names(which(tissues == i)), i] <- 1
  prop[names(which(tissues == i)), ! colnames(prop) \%in\% i] <- 0
}

# simulate over-dispersion
disp <- rlnorm(ngenes, -1)
names(disp) <- gene_names

# simulate counts and ERCC matrices
counts <- t(sapply(seq_len(ngenes), function(i) {
  eta <- exp(log(mu_gene[i]) + log(tech_factors) + log(size_factors \%*\% prop[i, ]))
  rnbinom(nsamples, mu = eta, size = 1/disp[i])
}))
colnames(counts) <- sample_names
rownames(counts) <- gene_names

ercc <- t(sapply(seq_len(nercc), function(i) {
  rpois(nsamples, exp(log(mu_gene[i]) + log(tech_factors)))
}))
colnames(ercc) <- sample_names
rownames(ercc) <- ercc_names

annots <- data.frame(Sample = sample_names)

# run standard normalization
nf <- normalizationFactor(counts)
norm <- normalizeCounts(counts, nf)

# run tissue-specific normalization
nf_tissues <- normalizationFactorTissueSpecific(counts, tissues)
norm_tissues <- normalizeCountsTissueSpecific(counts, nf_tissues, tissues)

# run regression
res <- tissueSpecificRegression(counts = counts,
                                ercc = ercc,
                                annots = annots,
                                tissues = tissues,
                                mean_design = ~1,
                                wald_test = FALSE,
                                cores = 1)

# check we recovered parameters
plot(exp(res$coefficients), mu_gene, log="xy")
abline(b=1, a=0)

plot(res$dispersions, disp, log="xy")
abline(b=1, a=0)

plot(res$tech_factors, tech_factors, log="xy")
abline(b=1, a=0)

plot(res$proportions[, 1], prop[, 1])
abline(b=1, a=0)

}
